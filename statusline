#! /bin/bash
#
# statusline :jsphsnkr - 2016
# Fetch various status elements and print to stdout at regular intervals.

clock() {
    date '+%a %H:%M'
    #h=$(date '+%_-I')
    #m=$(date '+%_-M')
    #syms=( 〇 一 二 三 四 五 六 七 八 九 十 十一 十二 )
    #echo "${syms[$h]} ${syms[($m / 10)]}十" 
}

battery() {
    bat=$(acpi --battery | cut -d, -f2 | cut -d ' ' -f2 | cut -d '%' -f1)
    if [ $bat -lt 10 ]
    then
        echo "BATTERY LOW!"
    fi
}

volume() {
    amixer -M get Master | awk -F"[][]" '/dB/ { print $2 }'
}

groups() {
    cur=`xprop -root _NET_CURRENT_DESKTOP | awk '{print $3}'`
    tot=`xprop -root _NET_NUMBER_OF_DESKTOPS | awk '{print $3}'`

    for w in `seq 0 $((cur - 1))`; do line="${line}- "; done
    line="${line}+ "
    for w in `seq $((cur + 2)) $tot`; do line="${line}- "; done
    echo $line
}

todo() {
    while read line; do
        if [[ "$line" =~ ^\# ]]
        then
            echo $line | cut -d ] -f2
        fi
    done < ~/Documents/todo.txt    
}


# Fill a buffer with status elements, then output it to stdout.
while :; do
    buf="%{l}   "
    buf="${buf}$(groups)"
    buf="${buf}%{c}$(battery)"
    buf="${buf}%{c}$(todo)"
    buf="${buf}%{r}$(clock)"
    echo "%{+u}${buf}   " 
    sleep 1
done
